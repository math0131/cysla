<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Aguarde — Animação Generativa (fix hairlines)</title>
  <style>
    :root {
      --bg: #0b0f14;
      --ink: #d5e1ff;
    }
    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--ink);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif;
      overflow: hidden; /* evita scroll e linhas na borda */
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
    canvas {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
      image-rendering: pixelated; /* ajuda a evitar blur em alguns drivers */
      will-change: transform;     /* acalma compositor */
      backface-visibility: hidden;
      transform: translateZ(0);
    }
    .center {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      pointer-events: none;
      text-transform: lowercase;
      letter-spacing: 0.12em;
      font-weight: 600;
      text-align: center;
      padding: 2rem;
    }
    .center span {
      font-size: clamp(1.2rem, 3vw + 1rem, 3rem);
      opacity: 0.95;
      animation: pulse 2s ease-in-out infinite;
      text-shadow: 0 2px 8px rgba(213,225,255,0.18);
    }
    @keyframes pulse {
      0%, 100% { transform: translateY(0); opacity: 0.95; }
      50%      { transform: translateY(-2px); opacity: 1; }
    }
    @media (prefers-reduced-motion: reduce) {
      .center span { animation: none; }
    }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div class="center"><span>aguarde</span></div>

  <script>
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d', { alpha: false }); // fundo opaco evita bandas/linhas
    const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

    let W = 0, H = 0, running = true;

    function resize() {
      // tamanho físico (pixels) ~ DPR
      const cssW = Math.floor(innerWidth);
      const cssH = Math.floor(innerHeight);
      W = canvas.width  = Math.max(1, Math.floor(cssW * DPR));
      H = canvas.height = Math.max(1, Math.floor(cssH * DPR));
      // tamanho CSS exato (sem frações)
      canvas.style.width  = cssW + 'px';
      canvas.style.height = cssH + 'px';

      // fundo totalmente opaco (sem linhas no clear)
      ctx.fillStyle = '#0b0f14';
      ctx.fillRect(0, 0, W, H);

      // configs “anti-hairline”
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.imageSmoothingEnabled = false;
    }
    addEventListener('resize', resize, { passive: true });
    resize();

    const prefersReducedMotion = matchMedia('(prefers-reduced-motion: reduce)');
    function updateMotionPreference() { running = !prefersReducedMotion.matches; }
    prefersReducedMotion.addEventListener?.('change', updateMotionPreference);
    updateMotionPreference();

    // parâmetros
    const PARTICLES = 1000;
    const SPEED = 0.7;
    const SCALE = 0.0018;
    const CURL  = 0.35;
    const TURN  = 0.018;
    const JITTER = 0.12;
    const COLORS = ['#a9b8ff','#9ad0ff','#c3f0ff','#8cc2ff'];

    const particles = [];
    const rand = (a,b)=>Math.random()*(b-a)+a;

    function spawn(i) {
      const r = Math.sqrt(Math.random()) * Math.hypot(W, H) * 0.4;
      const a = Math.random() * Math.PI * 2;
      const x = W/2 + Math.cos(a) * r;
      const y = H/2 + Math.sin(a) * r;
      particles[i] = { x, y, vx: rand(-1,1), vy: rand(-1,1), hue: COLORS[(Math.random()*COLORS.length)|0] };
    }
    for (let i=0;i<PARTICLES;i++) spawn(i);

    function flowAngle(x, y, t) {
      const nx = x * SCALE, ny = y * SCALE;
      const s = Math.sin(nx + t * 0.5);
      const c = Math.cos(ny * (1 + CURL) + t * 0.3);
      const v = s + c * (1 - CURL) + Math.sin((nx + ny) * 0.5 + t * 0.2);
      return v * Math.PI;
    }

    let last = performance.now();

    function snap(v){ return Math.round(v); } // snap para evitar subpixel

    function loop(now) {
      const dt = Math.min(0.033, (now - last) / 1000); last = now;

      // limpo com leve véu usando alpha global em vez de retângulos translúcidos acumulados
      ctx.globalCompositeOperation = 'source-over';
      ctx.globalAlpha = 1.0;
      ctx.fillStyle = '#0b0f14';
      ctx.fillRect(0, 0, W, H);
      ctx.globalAlpha = 0.06;
      ctx.fillStyle = '#0b0f14';
      ctx.fillRect(0, 0, W, H);
      ctx.globalAlpha = 1.0;

      for (let i=0;i<PARTICLES;i++) {
        const p = particles[i];
        const ang = flowAngle(p.x, p.y, now * 0.001);

        p.vx += Math.cos(ang) * TURN + (Math.random()-0.5)*JITTER;
        p.vy += Math.sin(ang) * TURN + (Math.random()-0.5)*JITTER;

        const len = Math.hypot(p.vx, p.vy) || 1;
        p.vx = (p.vx/len) * SPEED * DPR;
        p.vy = (p.vy/len) * SPEED * DPR;

        const x0 = snap(p.x), y0 = snap(p.y);
        p.x += p.vx; p.y += p.vy;

        // wrap
        if (p.x < 0) p.x += W; else if (p.x > W) p.x -= W;
        if (p.y < 0) p.y += H; else if (p.y > H) p.y -= H;

        // trilha
        ctx.beginPath();
        ctx.moveTo(x0, y0);
        ctx.lineTo(snap(p.x), snap(p.y));
        ctx.lineWidth = 1;
        ctx.strokeStyle = p.hue + 'cc';
        ctx.stroke();
      }

      if (running) requestAnimationFrame(loop);
    }

    addEventListener('visibilitychange', () => {
      running = !document.hidden && !prefersReducedMotion.matches;
      if (running) { last = performance.now(); requestAnimationFrame(loop); }
    });
    requestAnimationFrame(loop);
  </script>
</body>
</html>
